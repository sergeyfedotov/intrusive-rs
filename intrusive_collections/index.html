<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `intrusive_collections` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, intrusive_collections">

    <title>intrusive_collections - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Crate intrusive_collections</p><div class="block items"><ul><li><a href="#reexports">Reexports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'intrusive_collections', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>intrusive_collections</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/intrusive_collections/lib.rs.html#8-324' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Intrusive collections for Rust.</p>

<p>This library provides a set of high-performance intrusive collections which
can offer better performance and more flexibility than standard collections.</p>

<p>The main difference between an intrusive collection and a normal one is that
while normal collections allocate memory behind your back to keep track of a
set of <em>values</em>, intrusive collections never allocate memory themselves and
instead keep track of a set of <em>objects</em>. Such collections are called
intrusive because they requires explicit support in objects to allow them to
be inserted into a collection.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">intrusive_collections</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedList</span>, <span class="ident">LinkedListLink</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>;

<span class="comment">// A simple struct containing an instrusive link and a value</span>
<span class="kw">struct</span> <span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">value</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}

<span class="comment">// The adapter describes how an object can be inserted into an intrusive</span>
<span class="comment">// collection. This is automatically generated using a macro.</span>
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">TestAdapter</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create a list and some objects</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list</span> <span class="op">=</span> <span class="ident">LinkedList</span>::<span class="ident">new</span>(<span class="ident">TestAdapter</span>::<span class="ident">new</span>());
    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Test</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">1</span>),
    });
    <span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Test</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">2</span>),
    });
    <span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="ident">Test</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">3</span>),
    });

    <span class="comment">// Insert the objects at the front of the list</span>
    <span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">a</span>);
    <span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">b</span>);
    <span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">c</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>(), [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);

    <span class="comment">// At this point, the objects are owned by the list, and we can modify</span>
    <span class="comment">// them through the list.</span>
    <span class="ident">list</span>.<span class="ident">front</span>().<span class="ident">get</span>().<span class="ident">unwrap</span>().<span class="ident">value</span>.<span class="ident">set</span>(<span class="number">4</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>(), [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]);

    <span class="comment">// Removing an object from an instrusive collection gives us back the</span>
    <span class="comment">// Box&lt;Test&gt; that we originally inserted into it.</span>
    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">list</span>.<span class="ident">pop_front</span>().<span class="ident">unwrap</span>();
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">value</span>.<span class="ident">get</span>(), <span class="number">4</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>(), [<span class="number">2</span>, <span class="number">1</span>]);

    <span class="comment">// Dropping the collection will automatically free b and c by</span>
    <span class="comment">// transforming them back into Box&lt;Test&gt; and dropping them.</span>
    <span class="ident">drop</span>(<span class="ident">list</span>);
}</pre>

<h1 id='links-and-adapters' class='section-header'><a href='#links-and-adapters'>Links and adapters</a></h1>
<p>Intrusive collections track objects through links which are embedded within
the objects themselves. It also allows a single object to be part of
multiple intrusive collections at once by having multiple links in it.</p>

<p>The relationship between an object and a link inside it is described by the
<code>Adapter</code> trait. Intrusive collections use an implementation of this trait
to determine which link in an object should be used by the collection. In
most cases you do not need to write an implementation manually: the
<code>intrusive_adapter!</code> macro will automatically generate the necessary code.</p>

<p>For red-black trees, the adapter must also implement the <code>KeyAdapter</code> trait
which allows a key to be extracted from an object. This key is then used to
keep all elements in the tree in ascending order.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">intrusive_collections</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">SinglyLinkedListLink</span>, <span class="ident">SinglyLinkedList</span>};
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedListLink</span>, <span class="ident">LinkedList</span>};
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">RBTreeLink</span>, <span class="ident">RBTree</span>, <span class="ident">KeyAdapter</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">rc</span>::<span class="ident">Rc</span>;

<span class="comment">// This struct can be inside two lists and one tree simultaneously</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Default</span>)]</span>
<span class="kw">struct</span> <span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">link2</span>: <span class="ident">SinglyLinkedListLink</span>,
    <span class="ident">link3</span>: <span class="ident">RBTreeLink</span>,
    <span class="ident">value</span>: <span class="ident">i32</span>,
}

<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">MyAdapter</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">MyAdapter2</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link2</span>: <span class="ident">SinglyLinkedListLink</span> });
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">MyAdapter3</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link3</span>: <span class="ident">RBTreeLink</span> });
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">KeyAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyAdapter3</span> {
    <span class="kw">type</span> <span class="ident">Key</span> <span class="op">=</span> <span class="ident">i32</span>;
    <span class="kw">fn</span> <span class="ident">get_key</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Test</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> { <span class="ident">x</span>.<span class="ident">value</span> }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">LinkedList</span>::<span class="ident">new</span>(<span class="ident">MyAdapter</span>::<span class="ident">new</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">SinglyLinkedList</span>::<span class="ident">new</span>(<span class="ident">MyAdapter2</span>::<span class="ident">new</span>());
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">RBTree</span>::<span class="ident">new</span>(<span class="ident">MyAdapter3</span>::<span class="ident">new</span>());

    <span class="kw">let</span> <span class="ident">test</span> <span class="op">=</span> <span class="ident">Rc</span>::<span class="ident">new</span>(<span class="ident">Test</span>::<span class="ident">default</span>());
    <span class="ident">a</span>.<span class="ident">push_front</span>(<span class="ident">test</span>.<span class="ident">clone</span>());
    <span class="ident">b</span>.<span class="ident">push_front</span>(<span class="ident">test</span>.<span class="ident">clone</span>());
    <span class="ident">c</span>.<span class="ident">insert</span>(<span class="ident">test</span>);
}</pre>

<h1 id='cursors' class='section-header'><a href='#cursors'>Cursors</a></h1>
<p>Intrusive collections are manipulated using cursors. A cursor is similar to
an iterator, except that it can freely seek back-and-forth, and can safely
mutate the list during iteration. This is similar to how a C++ iterator
works.</p>

<p>A cursor views an intrusive collection as a circular list, with a special
null object between the last and first elements of the collection. A cursor
will either point to a valid object in the collection or to this special
null object.</p>

<p>Cursors come in two forms: <code>Cursor</code> and <code>CursorMut</code>. A <code>Cursor</code> gives a
read-only view of a collection, but you are allowed to use multiple <code>Cursor</code>
objects simultaneously on the same collection. On the other hand,
<code>CursorMut</code> can be used to mutate the collection, but you may only use one
of them at a time.</p>

<p>Cursors are a very powerful abstraction since they allow a collection to be
mutated safely while it is being iterated on. For example, here is a
function which removes all values within a given range from a <code>RBTree</code>:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">intrusive_collections</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">RBTreeLink</span>, <span class="ident">RBTree</span>, <span class="ident">KeyAdapter</span>, <span class="ident">Bound</span>};

<span class="kw">struct</span> <span class="ident">Element</span> {
    <span class="ident">link</span>: <span class="ident">RBTreeLink</span>,
    <span class="ident">value</span>: <span class="ident">i32</span>,
}

<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">ElementAdapter</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Element</span><span class="op">&gt;</span>: <span class="ident">Element</span> { <span class="ident">link</span>: <span class="ident">RBTreeLink</span> });
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">KeyAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">ElementAdapter</span> {
    <span class="kw">type</span> <span class="ident">Key</span> <span class="op">=</span> <span class="ident">i32</span>;
    <span class="kw">fn</span> <span class="ident">get_key</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Element</span>) <span class="op">-&gt;</span> <span class="ident">i32</span> { <span class="ident">e</span>.<span class="ident">value</span> }
}

<span class="kw">fn</span> <span class="ident">remove_range</span>(<span class="ident">tree</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">RBTree</span><span class="op">&lt;</span><span class="ident">ElementAdapter</span><span class="op">&gt;</span>, <span class="ident">min</span>: <span class="ident">i32</span>, <span class="ident">max</span>: <span class="ident">i32</span>) {
    <span class="comment">// Find the first element which is greater than or equal to min</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cursor</span> <span class="op">=</span> <span class="ident">tree</span>.<span class="ident">lower_bound_mut</span>(<span class="ident">Bound</span>::<span class="ident">Included</span>(<span class="kw-2">&amp;</span><span class="ident">min</span>));

    <span class="comment">// Iterate over all elements in the range [min, max]</span>
    <span class="kw">while</span> <span class="ident">cursor</span>.<span class="ident">get</span>().<span class="ident">map_or</span>(<span class="bool-val">false</span>, <span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">value</span> <span class="op">&lt;=</span> <span class="ident">max</span>) {
        <span class="comment">// CursorMut::remove will return a Some(&lt;Box&lt;Element&gt;), which we</span>
        <span class="comment">// simply drop here.</span>
        <span class="ident">cursor</span>.<span class="ident">remove</span>();

        <span class="comment">// Advance to the next element</span>
        <span class="ident">cursor</span>.<span class="ident">move_next</span>();
    }
}</pre>

<h1 id='scoped-collections' class='section-header'><a href='#scoped-collections'>Scoped collections</a></h1>
<p>Instead of taking ownership of objects inserted into them, intrusive
collections can also work with borrowed values. This works by using
lifetimes and the borrow checker to ensure that any objects inserted into an
intrusive collection will outlive the collection itself.</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">intrusive_collections</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">typed_arena</span>;

<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedListLink</span>, <span class="ident">LinkedList</span>};
<span class="kw">use</span> <span class="ident">typed_arena</span>::<span class="ident">Arena</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>;

<span class="kw">struct</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">value</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}

<span class="comment">// Note that we use a plain reference as the pointer type for the collection.</span>
<span class="macro">intrusive_adapter</span><span class="macro">!</span>(<span class="ident">ValueAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Value</span>: <span class="ident">Value</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create an arena and a list. Note that since stack objects are dropped in</span>
    <span class="comment">// reverse order, the Arena must be created before the LinkedList. This</span>
    <span class="comment">// ensures that the list is dropped before the values are freed by the</span>
    <span class="comment">// arena. This is enforced by the Rust lifetime system.</span>
    <span class="kw">let</span> <span class="ident">arena</span> <span class="op">=</span> <span class="ident">Arena</span>::<span class="ident">new</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list</span> <span class="op">=</span> <span class="ident">LinkedList</span>::<span class="ident">new</span>(<span class="ident">ValueAdapter</span>::<span class="ident">new</span>());

    <span class="comment">// We can now insert values allocated from the arena into the linked list</span>
    <span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">1</span>),
    }));
    <span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">2</span>),
    }));
    <span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">3</span>),
    }));
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>(), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);

    <span class="comment">// We can also insert stack allocated values into an intrusive list.</span>
    <span class="comment">// Again, the values must outlive the LinkedList.</span>
    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Value</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">4</span>),
    };
    <span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">Value</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">5</span>),
    };
    <span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Value</span> {
        <span class="ident">link</span>: <span class="ident">LinkedListLink</span>::<span class="ident">new</span>(),
        <span class="ident">value</span>: <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">6</span>),
    };
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list2</span> <span class="op">=</span> <span class="ident">LinkedList</span>::<span class="ident">new</span>(<span class="ident">ValueAdapter</span>::<span class="ident">new</span>());
    <span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">a</span>);
    <span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>);
    <span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">c</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list2</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>(), [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);

    <span class="comment">// Since these are shared references, any changes in the values are reflected in</span>
    <span class="comment">// the list.</span>
    <span class="ident">a</span>.<span class="ident">value</span>.<span class="ident">set</span>(<span class="number">7</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">list2</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>(), [<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>]);
}</pre>

<h1 id='safety' class='section-header'><a href='#safety'>Safety</a></h1>
<p>While it is possible to use intrusive collections without any unsafe code,
this crate also exposes a few unsafe features.</p>

<p>The <code>cursor_from_ptr</code> and <code>cursor_mut_from_ptr</code> allow you to create a
cursor pointing to a specific element in the collection from a pointer to
that element. This is unsafe because it assumes that the objected pointed to
is currently inserted in the collection.</p>

<p>The <code>UnsafeRef</code> type acts like <code>Rc</code>, except without the reference count.
Instead, you are responsible for keeping track of the number of active
references to an object and for freeing it once the last reference is
dropped. The advantage of <code>UnsafeRef</code> over <code>Rc</code> is that it reduces the size
of the allocation by two <code>usize</code> and avoids the overhead of maintaining
reference counts.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use singly_linked_list::<a class="struct" href="../intrusive_collections/singly_linked_list/struct.SinglyLinkedList.html" title="struct intrusive_collections::singly_linked_list::SinglyLinkedList">SinglyLinkedList</a>;</code></td></tr><tr><td><code>pub use singly_linked_list::<a class="struct" href="../intrusive_collections/singly_linked_list/struct.Link.html" title="struct intrusive_collections::singly_linked_list::Link">Link</a> as SinglyLinkedListLink;</code></td></tr><tr><td><code>pub use linked_list::<a class="struct" href="../intrusive_collections/linked_list/struct.LinkedList.html" title="struct intrusive_collections::linked_list::LinkedList">LinkedList</a>;</code></td></tr><tr><td><code>pub use linked_list::<a class="struct" href="../intrusive_collections/linked_list/struct.Link.html" title="struct intrusive_collections::linked_list::Link">Link</a> as LinkedListLink;</code></td></tr><tr><td><code>pub use rbtree::<a class="struct" href="../intrusive_collections/rbtree/struct.RBTree.html" title="struct intrusive_collections::rbtree::RBTree">RBTree</a>;</code></td></tr><tr><td><code>pub use rbtree::<a class="struct" href="../intrusive_collections/rbtree/struct.Link.html" title="struct intrusive_collections::rbtree::Link">Link</a> as RBTreeLink;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="mod" href="linked_list/index.html"
                                  title='mod intrusive_collections::linked_list'>linked_list</a></td>
                           <td class='docblock-short'>
                                <p>Intrusive doubly-linked list.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="rbtree/index.html"
                                  title='mod intrusive_collections::rbtree'>rbtree</a></td>
                           <td class='docblock-short'>
                                <p>Intrusive red-black tree.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="singly_linked_list/index.html"
                                  title='mod intrusive_collections::singly_linked_list'>singly_linked_list</a></td>
                           <td class='docblock-short'>
                                <p>Intrusive singly-linked list.</p>
                           </td>
                       </tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.container_of.html"
                                  title='macro intrusive_collections::container_of'>container_of</a></td>
                           <td class='docblock-short'>
                                <p>Unsafe macro to get a raw pointer to an outer object from a pointer to one
of its fields.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.intrusive_adapter.html"
                                  title='macro intrusive_collections::intrusive_adapter'>intrusive_adapter</a></td>
                           <td class='docblock-short'>
                                <p>Macro to generate an implementation of <code>Adapter</code> for a given set of types.
In particular this will automatically generate implementations of the
<code>get_value</code> and <code>get_link</code> methods for a given named field in a struct.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.offset_of.html"
                                  title='macro intrusive_collections::offset_of'>offset_of</a></td>
                           <td class='docblock-short'>
                                <p>Macro to get the offset of a struct field in bytes from the address of the
struct.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.offset_of_unsafe.html"
                                  title='macro intrusive_collections::offset_of_unsafe'>offset_of_unsafe</a></td>
                           <td class='docblock-short'>
                                <p>Macro to get the offset of a struct field in bytes from the address of the
struct.</p>
                           </td>
                       </tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.UnsafeRef.html"
                                  title='struct intrusive_collections::UnsafeRef'>UnsafeRef</a></td>
                           <td class='docblock-short'>
                                <p>Unchecked shared pointer</p>
                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Bound.html"
                                  title='enum intrusive_collections::Bound'>Bound</a></td>
                           <td class='docblock-short'>
                                <p>An endpoint of a range of keys.</p>
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Adapter.html"
                                  title='trait intrusive_collections::Adapter'>Adapter</a></td>
                           <td class='docblock-short'>
                                <p>Trait for a adapter which allows a type to be inserted into an intrusive
collection. The <code>Link</code> type contains the collection-specific metadata which
allows an object to be inserted into an intrusive collection. This type
needs to match the collection type (eg. <code>LinkedListLink</code> for inserting
in a <code>LinkedList</code>).</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.IntrusivePointer.html"
                                  title='trait intrusive_collections::IntrusivePointer'>IntrusivePointer</a></td>
                           <td class='docblock-short'>
                                <p>Trait representing an owned pointer type which can be converted to and from
a raw pointer.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.KeyAdapter.html"
                                  title='trait intrusive_collections::KeyAdapter'>KeyAdapter</a></td>
                           <td class='docblock-short'>
                                <p>Extension of the <code>Adapter</code> trait to provide a way of extracting a key from
an object. This key can then be used as an index in certain intrusive
collections (currently only <code>RBTree</code> uses this).</p>
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "intrusive_collections";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>